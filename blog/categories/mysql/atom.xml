<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: mysql | NoMethodError]]></title>
  <link href="http://nomethoderror.com//blog/categories/mysql/atom.xml" rel="self"/>
  <link href="http://nomethoderror.com//"/>
  <updated>2015-05-30T13:15:52-05:00</updated>
  <id>http://nomethoderror.com//</id>
  <author>
    <name><![CDATA[Travis Roberts]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ActiveRecord Random Ordering with Pagination]]></title>
    <link href="http://nomethoderror.com//blog/2014/02/05/activerecord-random-ordering-with-pagination/"/>
    <updated>2014-02-05T21:18:00-06:00</updated>
    <id>http://nomethoderror.com//blog/2014/02/05/activerecord-random-ordering-with-pagination</id>
    <content type="html"><![CDATA[<p>When I created <a href="http://nshvll.org/">nshvll.org</a>, I wanted the ability to show the user a randomly ordered list of members. I also wanted to paginate the results, and I didn&rsquo;t know if it was possible to have both. After a little research, I found that you can pass a seed to the mySQL <code>RAND()</code> function and have it return an identical list each time it&rsquo;s called.</p>

<h2>mySQL</h2>

<p>Since I want each person to get a uniquely randomized list of members, I set a cookie with a seed which is randomly generated (1-100).</p>

<p>I set the seed in a <code>before_filter</code> in my <code>ApplicationController</code>.</p>

<p><div><script src='https://gist.github.com/8838030.js?file=application_controller_mysql.rb'></script>
<noscript><pre><code>class ApplicationController &lt; ActionController::Base
  before_filter :set_rand_cookie

  private
  
  def set_rand_cookie
    return if cookies[:rand_seed].present?
    cookies[:rand_seed] = {value: rand(100), expires: Time.now + 900}
  end
end</code></pre></noscript></div>
</p>

<p>Notice, I only set the cookie if it doesn&rsquo;t exist. I also set the expiration of the cookie to 15 minutes because I don&rsquo;t want the user to get the same list of members <em>all</em> the time.</p>

<p>Now, in the <code>MembersController</code>, I can pass that seed to mySQL and get a repeatable sequence of random records.</p>

<p><div><script src='https://gist.github.com/8838030.js?file=members_controller_mysql.rb'></script>
<noscript><pre><code>class MembersController &lt; ApplicationController

  def index
    @members = Member.order(&quot;RAND(#{cookies[:rand_seed]})&quot;).page(params[:page]).per(15)
  end
  
end</code></pre></noscript></div>
</p>

<h2>PostgreSQL</h2>

<p>A little while after I built the site, I decided to move it from a personal VPS to <a href="https://www.heroku.com/">Heroku</a>. To do that, I needed to convert the database to PostgreSQL (or pay for a mySQL option). After a little research, I found out that PostgreSQL is a bit trickier than mySQL when it comes to using a seed with the <code>random()</code> function. You have to run a separate select query to set the seed before the query that gets the list of records.</p>

<p><div><script src='https://gist.github.com/8838030.js?file=members_controller_postgres.rb'></script>
<noscript><pre><code>class MembersController &lt; ApplicationController

  def index
    Member.connection.execute(&quot;select setseed(#{cookies[:rand_seed]})&quot;)
    @members = Member.order(&#39;random()&#39;).page(params[:page]).per(15)
  end

end</code></pre></noscript></div>
</p>

<p>PostgreSQL&rsquo;s <code>setseed()</code> function requires a number between -1 and 1, so we need to switch to a random float instead of an integer in the <code>ApplicationController</code></p>

<p><div><script src='https://gist.github.com/8838030.js?file=application_controller_postgres.rb'></script>
<noscript><pre><code>class ApplicationController &lt; ActionController::Base
  before_filter :set_rand_cookie

  private
  
  def set_rand_cookie
    return if cookies[:rand_seed].present?
    cookies[:rand_seed] = {value: rand, expires: Time.now + 900}
  end
end</code></pre></noscript></div>
</p>

<p>There we go. A repeatable, randomized set of records in mySQL or PostgreSQL.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Converting a Rails Database from mySQL to PostgreSQL]]></title>
    <link href="http://nomethoderror.com//blog/2013/10/03/converting-a-rails-database-from-mysql-to-postgresql/"/>
    <updated>2013-10-03T18:18:00-05:00</updated>
    <id>http://nomethoderror.com//blog/2013/10/03/converting-a-rails-database-from-mysql-to-postgresql</id>
    <content type="html"><![CDATA[<p>The <a href="https://github.com/ricardochimal/taps">taps</a> gem allows you to transfer database structure and data easily between db types.</p>

<h2>Add the necessary gems to your Gemfile</h2>

<p><div><script src='https://gist.github.com/6818918.js?file=1_gemfile.rb'></script>
<noscript><pre><code>gem &#39;taps&#39;
gem &#39;sqlite3&#39; # dependency of taps</code></pre></noscript></div>
</p>

<p>Make sure you have the gems for both db types you&rsquo;ll be accessing.</p>

<p><div><script src='https://gist.github.com/6818918.js?file=2_gemfile.rb'></script>
<noscript><pre><code>gem &#39;mysql2&#39;
gem &#39;pg&#39;</code></pre></noscript></div>
</p>

<h2>Start the taps server</h2>

<p>This will connect to the database that you are copying structure/date <em>from</em>.</p>

<p><div><script src='https://gist.github.com/6818918.js?file=3_taps.sh'></script>
<noscript><pre><code>taps server mysql2://username:password@localhost/dbname authusername authpassword</code></pre></noscript></div>
</p>

<p><code>authusername</code> and <code>authpassword</code> can be whatever you want. This will be used to authenticate when pulling from this db server.</p>

<h2>Pull the data into your new database</h2>

<p>Make sure the new database has been created.</p>

<p><div><script src='https://gist.github.com/6818918.js?file=4_taps.sh'></script>
<noscript><pre><code>taps pull postgres://username:password@localhost/dbname http://authusername:authpassword@localhost:5000</code></pre></noscript></div>
</p>

<p>Done!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using God Gem to Monitor mySQL]]></title>
    <link href="http://nomethoderror.com//blog/2011/10/02/using-god-gem-to-monitor-mysql/"/>
    <updated>2011-10-02T12:00:00-05:00</updated>
    <id>http://nomethoderror.com//blog/2011/10/02/using-god-gem-to-monitor-mysql</id>
    <content type="html"><![CDATA[<p>I recently ran into a problem on a client server where the <code>msyqld</code> process died, and neither of us noticed it for almost 24 hours. That meant that the site was completely useless that entire time. Needless to say, the client wasn&rsquo;t thrilled about this.</p>

<p>I told him that I&rsquo;d look into setting up a monitoring service to, at the very least, notify me if <code>msyqld</code> ever crashed. During my research, I stumbled upon the god gem (which I&rsquo;d used in the past to monitor mongrel processes back in the days before Passenger). I didn&rsquo;t realize it could be used to monitor other processes as well, such as <code>msyqld</code>.</p>

<p>God is a rubygem, so it&rsquo;s easy to install on any *nix operating system. It&rsquo;s config files are also written in Ruby, so that makes it even better.</p>

<p>What you&rsquo;ll need to get the script running:</p>

<ol>
<li><p>Install the god gem (as root).</p>

<p><pre>sudo gem install god</pre></p></li>
<li><p>Find the location of your <code>msyqld</code> pid file.</p>

<p><pre>mysqladmin -u root -p variables | grep pid_file</pre></p></li>
<li><p>Determine the command to start/stop/restart the <code>msyqld</code> service. Usually <code>/etc/init.d/mysqld</code></p></li>
</ol>


<p>Here is the config file I wrote to watch my mysqld process:</p>

<p><div><script src='https://gist.github.com/c1f96cfc74a73316c35b.js?file=mysql.rb'></script>
<noscript><pre><code>  # run in non-daemonized mode (so you can monitor it) with `god -c /path/to/mysql.god -D`
  # run normally with `god -c /path/to/mysql.god`

  # Settings for email notifications (optional)
  God::Contacts::Email.defaults do |d|
    d.from_email = &#39;god@my-app.com&#39;
    d.from_name = &#39;God&#39;
    d.delivery_method = :smtp # this can also be :sendmail
    d.server_host = &#39;smtp.myapp.com&#39;
    d.server_port = 25
    d.server_auth = true
    d.server_domain = &#39;myapp.com&#39;
    d.server_user = &#39;smtp_user@myapp.com&#39;
    d.server_password = &#39;password&#39;
  end

  # you can create as many email entries as you&#39;d like
  God.contact(:email) do |c|
    c.name = &#39;me&#39;
    c.to_email = &#39;me@email.com&#39;
  end

  God.watch do |w|
    # you can name this whatever you want
    w.name = &quot;mySQL Server&quot;

    # polling interval
    w.interval = 30.seconds

    # command to start service
    w.start = &quot;/etc/init.d/mysqld start &amp;&amp; /etc/init.d/httpd restart&quot;

    # command to stop service
    w.stop = &quot;/etc/init.d/mysqld stop&quot;

    # command to restart service
    w.restart = &quot;/etc/init.d/mysqld restart &amp;&amp; /etc/init.d/httpd restart&quot;

    # how long to wait after starting service before monitoring resumes
    w.start_grace = 20.seconds

    # how long to wait after restarting service before monitoring resumes
    w.restart_grace = 20.seconds

    # location of pid file
    w.pid_file = &quot;/var/run/mysqld/mysqld.pid&quot;

    # tell god to delete the pid file when mysqld crashes
    w.behavior(:clean_pid_file)

    # determine the state on startup
    w.transition(:init, { true =&gt; :up, false =&gt; :start }) do |on|
      on.condition(:process_running) do |c|
        c.running = true
      end
    end

    # determine when process has finished starting
    w.transition([:start, :restart], :up) do |on|
      on.condition(:process_running) do |c|
        c.running = true
      end
      # failsafe
      on.condition(:tries) do |c|
        c.times = 8
        c.within = 2.minutes
        c.transition = :start
      end
    end

    # start if process is not running
    w.transition(:up, :start) do |on|
      on.condition(:process_exits) do |c|
        # send an email to me to notify me that the service has crashed
        c.notify = &#39;me&#39;
      end
    end

    # lifecycle
    w.lifecycle do |on|
      # If the service keeps triggering a restart over and over, it is considered to be &quot;flapping&quot;.
      on.condition(:flapping) do |c|
        c.to_state = [:start, :restart]
        c.times = 5
        c.within = 1.minute
        c.transition = :unmonitored
        # If the service is flapping, wait 10 minutes, then try to start/restart again.
        c.retry_in = 10.minutes
        c.retry_times = 5
        c.retry_within = 2.hours
      end
    end
  end</code></pre></noscript></div>
</p>

<p>A few things to note about my script:</p>

<ol>
<li>In my start and restart commands, I also restart Apache. Running my site with Passenger, I would get a Rack error when <code>mysqld</code> restarted, but apache hadn&rsquo;t. YMMV.</li>
<li>I&rsquo;m using an SMTP server for my email notification. You can also use <code>sendmail</code>, or you can exclude the email notifications altogether.</li>
<li>When running the script for the first time, it&rsquo;s a good idea to add the <code>-D</code> flag. This runs god in non-daemonized mode so all output is piped to STDOUT. That way, you can watch what it&rsquo;s doing to ensure everything is working correctly.</li>
</ol>


<p>For more information about the god gem, see their site: <a href="http://god.rubyforge.org/">god.rubyforge.org</a></p>
]]></content>
  </entry>
  
</feed>
